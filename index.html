<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>pixi</title>
  <script src="./js/pixi.min.js"></script>
  <script src="./js/scaleToWindow.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <script>
    // 检测是否支持WebGL
    let type = "WebGL"
    if (!PIXI.utils.isWebGLSupported()) {
      type = "canvas"
    }
    PIXI.utils.sayHello(type)

    // 创建舞台
    let app = new PIXI.Application({
      width: 750,
      height: 750
    })
    app.renderer.autoResize = true;
    document.body.appendChild(app.view)
    scaleToWindow(app.view);
    window.addEventListener("resize", function (event) {
      scaleToWindow(app.view);
    });

    // 资源通过loader加载到纹理缓存中
    PIXI.loader
      .add([
        "images/bajian.json",
        "images/daiji.json",
        "images/huanhu.json",
        "images/jiaozheng.json",
        "images/jzhbj.json",
        "images/jzhdj.json",
        "images/bucket.png",
        "images/finger.png",
        "images/bg.png",
        "images/fire.json",
        "images/bandage.png",
        "images/water.json"
      ])
      .on("progress", loadProgressHandler)
      .load(setup)

    function loadProgressHandler(loader, resource) {
      console.log(`${resource.url}: ${loader.progress}%`)
    }
    let finger, bucket, bandage, bg
    function setup() {
      // 背景
      bg = new PIXI.Sprite(
        PIXI.loader.resources["images/bg.png"].texture
      );

      bg.width = 750
      bg.height = 750
      bg.position.set(0, 0)
      app.stage.addChild(bg)
      


      // 待机
      let djArr = []
      for (let i = 0; i < 10; i++) {
        let texture
        if (i < 10) {
          texture = PIXI.Texture.fromFrame(`哥布林待机_0000${i}.png`)
        } else {
          texture = PIXI.Texture.fromFrame(`哥布林待机_000${i}.png`)
        }
        djArr.push(texture)
      }

      let dj = new PIXI.extras.AnimatedSprite(djArr)
      dj.width = 500
      dj.height = 500
      dj.position.set(0, 300)
      dj.animationSpeed = 0.2;
      app.stage.addChild(dj)
      dj.interactive = true;
      dj.loop = true
      dj.play();

      // 着火
      let fireArr = []
      for (let i = 0; i < 9; i++) {
        let texture
        if (i < 10) {
          texture = PIXI.Texture.fromFrame(`着火_0000${i}.png`)
        } else {
          texture = PIXI.Texture.fromFrame(`着火_000${i}.png`)
        }
        fireArr.push(texture)
      }

      let fire = new PIXI.extras.AnimatedSprite(fireArr)
      fire.width = 300
      fire.height = 300
      fire.position.set(40, 190)
      fire.animationSpeed = 0.3;
      app.stage.addChild(fire)
      fire.interactive = true;
      fire.loop = true
      fire.play();

      // 绷带
      bandage = new PIXI.Sprite(
        PIXI.loader.resources["images/bandage.png"].texture
      );
      bandage.width = 200
      bandage.height = 200
      bandage.position.set(600, 200)
      bandage.interactive = true;
      bandage.buttonMode = true;
      bandage.anchor.set(0.5);
      bandage.scale.set(0.5)
      bandage.on('pointerdown', onDragStart)
        .on('pointerup', onDragEnd)
        .on('pointerupoutside', onDragEnd)
        .on('pointermove', onDragMove);

      app.stage.addChild(bandage)

      // 水桶
      bucket = new PIXI.Sprite(
        PIXI.loader.resources["images/bucket.png"].texture
      );
      bucket.width = 200
      bucket.height = 200
      bucket.position.set(600, 350)
      bucket.interactive = true;
      bucket.buttonMode = true;
      bucket.anchor.set(0.5);
      bucket.on('pointerdown', onDragStart)
        .on('pointerup', onDragEnd)
        .on('pointerupoutside', onDragEnd)
        .on('pointermove', onDragMove);

      app.stage.addChild(bucket)


      // 手
      finger = new PIXI.Sprite(
        PIXI.loader.resources["images/finger.png"].texture
      );
      finger.width = 400
      finger.height = 400
      finger.position.set(500, 400)
      finger.interactive = true;
      finger.buttonMode = true;
      finger.anchor.set(0.5);
      finger.scale.set(0.5)
      finger.on('pointerdown', onDragStart)
        .on('pointerup', onDragEnd)
        .on('pointerupoutside', onDragEnd)
        .on('pointermove', onDragMove);
      app.stage.addChild(finger)

      // 浇水
      let waterArr = []
      for (let i = 0; i < 8; i++) {
        let texture
        if (i < 10) {
          texture = PIXI.Texture.fromFrame(`浇水_0000${i}.png`)
        } else {
          texture = PIXI.Texture.fromFrame(`浇水_000${i}.png`)
        }
        waterArr.push(texture)
      }

      let water = new PIXI.extras.AnimatedSprite(waterArr)
      water.width = 300
      water.height = 300
      water.position.set(40, 170)
      water.animationSpeed = 0.3;
      app.stage.addChild(water)
      water.interactive = true;
      water.loop = true
      water.play();





      // 脚正待机
      let jzhdjArr = []
      for (let i = 0; i < 14; i++) {
        let texture
        if (i < 10) {
          texture = PIXI.Texture.fromFrame(`脚正待机_0000${i}.png`)
        } else {
          texture = PIXI.Texture.fromFrame(`脚正待机_000${i}.png`)
        }
        jzhdjArr.push(texture)
      }

      let jzhdj = new PIXI.extras.AnimatedSprite(jzhdjArr)
      jzhdj.width = 250
      jzhdj.height = 250
      jzhdj.position.set(300, 0)
      jzhdj.animationSpeed = 0.2;
      // app.stage.addChild(jzhdj)
      jzhdj.interactive = true;
      jzhdj.loop = true
      jzhdj.on('pointerdown', function () {
        jzhdj.play();
      })



      // 脚正
      let jzhArr = []
      for (let i = 0; i < 15; i++) {
        let texture
        if (i < 10) {
          texture = PIXI.Texture.fromFrame(`脚正_0000${i}.png`)
        } else {
          texture = PIXI.Texture.fromFrame(`脚正_000${i}.png`)
        }
        jzhArr.push(texture)
      }

      let jzh = new PIXI.extras.AnimatedSprite(jzhArr)
      jzh.width = 250
      jzh.height = 250
      jzh.position.set(0, 300)
      jzh.animationSpeed = 0.2;
      // app.stage.addChild(jzh)
      jzh.interactive = true;
      jzh.loop = false
      jzh.on('pointerdown', function () {
        jzh.play();
      })

      // 欢呼
      let hhArr = []
      for (let i = 0; i < 9; i++) {
        let texture
        if (i < 10) {
          texture = PIXI.Texture.fromFrame(`欢呼_0000${i}.png`)
        } else {
          texture = PIXI.Texture.fromFrame(`欢呼_000${i}.png`)
        }
        hhArr.push(texture)
      }

      let hh = new PIXI.extras.AnimatedSprite(hhArr)
      hh.width = 250
      hh.height = 250
      hh.position.set(300, 300)
      hh.animationSpeed = 0.2;
      // app.stage.addChild(hh)
      hh.interactive = true;
      hh.loop = true
      hh.on('pointerdown', function () {
        hh.play();
      })

      // 拔箭
      let bjArr = []
      for (let i = 0; i < 27; i++) {
        let texture
        if (i < 10) {
          texture = PIXI.Texture.fromFrame(`拔箭_0000${i}.png`)
        } else {
          texture = PIXI.Texture.fromFrame(`拔箭_000${i}.png`)
        }
        bjArr.push(texture)
      }

      let bj = new PIXI.extras.AnimatedSprite(bjArr)
      bj.width = 250
      bj.height = 250
      bj.position.set(0, 600)
      bj.animationSpeed = 0.2;
      // app.stage.addChild(bj)
      bj.interactive = true;
      bj.loop = false
      bj.on('pointerdown', function () {
        bj.play();
      })


      // 脚正拔箭
      let jzhebjArr = []
      for (let i = 0; i < 26; i++) {
        let texture
        if (i < 10) {
          texture = PIXI.Texture.fromFrame(`脚正拔箭_0000${i}.png`)
        } else {
          texture = PIXI.Texture.fromFrame(`脚正拔箭_000${i}.png`)
        }
        jzhebjArr.push(texture)
      }

      let jzhebj = new PIXI.extras.AnimatedSprite(jzhebjArr)
      jzhebj.width = 250
      jzhebj.height = 250
      jzhebj.position.set(300, 600)
      jzhebj.animationSpeed = 0.2;
      // app.stage.addChild(jzhebj)
      jzhebj.interactive = true;
      jzhebj.loop = false
      jzhebj.on('pointerdown', function () {
        jzhebj.play();
      })


      // 碰撞检测
      if (hitTestRectangle(finger, bucket)) {
        console.log('碰撞了。。。')
      } else {

      }


      // gameLoop();
    }
    let state = play;
    function gameLoop() {
      // 循环调用gameLoop
      requestAnimationFrame(gameLoop);
      state();
    }
    function play() {
      if (hitTestRectangle(finger, bucket)) {
        console.log("碰撞到了!");
        bucket.x = finger.x
        bucket.y = finger.y
      } else {
      }
    }


    function onDragStart(event) {
      this.data = event.data;
      this.alpha = 1;
      this.dragging = true;
    }

    function onDragEnd() {
      this.alpha = 1;
      this.dragging = false;
      this.data = null;
    }

    function onDragMove() {
      if (this.dragging) {
        const newPosition = this.data.getLocalPosition(this.parent);
        this.x = newPosition.x;
        this.y = newPosition.y;
      }

    }

    function hitTestRectangle(r1, r2) {

      //Define the variables we'll need to calculate
      let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

      //hit will determine whether there's a collision
      hit = false;

      //Find the center points of each sprite
      r1.centerX = r1.x + r1.width / 2;
      r1.centerY = r1.y + r1.height / 2;
      r2.centerX = r2.x + r2.width / 2;
      r2.centerY = r2.y + r2.height / 2;

      //Find the half-widths and half-heights of each sprite
      r1.halfWidth = r1.width / 2;
      r1.halfHeight = r1.height / 2;
      r2.halfWidth = r2.width / 2;
      r2.halfHeight = r2.height / 2;

      //Calculate the distance vector between the sprites
      vx = r1.centerX - r2.centerX;
      vy = r1.centerY - r2.centerY;

      //Figure out the combined half-widths and half-heights
      combinedHalfWidths = r1.halfWidth + r2.halfWidth;
      combinedHalfHeights = r1.halfHeight + r2.halfHeight;

      //Check for a collision on the x axis
      if (Math.abs(vx) < combinedHalfWidths) {

        //A collision might be occuring. Check for a collision on the y axis
        if (Math.abs(vy) < combinedHalfHeights) {

          //There's definitely a collision happening
          hit = true;
        } else {

          //There's no collision on the y axis
          hit = false;
        }
      } else {

        //There's no collision on the x axis
        hit = false;
      }

      //`hit` will be either `true` or `false`
      return hit;
    };
  </script>
</body>

</html>